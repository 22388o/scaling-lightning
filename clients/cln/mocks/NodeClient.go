// Code generated by mockery v2.29.0. DO NOT EDIT.

package mocks

import (
	context "context"

	google_golang_orggrpc "google.golang.org/grpc"

	grpc "github.com/scaling-lightning/scaling-lightning/clients/cln/grpc"

	mock "github.com/stretchr/testify/mock"
)

// NodeClient is an autogenerated mock type for the NodeClient type
type NodeClient struct {
	mock.Mock
}

// AddGossip provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) AddGossip(ctx context.Context, in *grpc.AddgossipRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.AddgossipResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.AddgossipResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.AddgossipRequest, ...google_golang_orggrpc.CallOption) (*grpc.AddgossipResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.AddgossipRequest, ...google_golang_orggrpc.CallOption) *grpc.AddgossipResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.AddgossipResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.AddgossipRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AutoCleanInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) AutoCleanInvoice(ctx context.Context, in *grpc.AutocleaninvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.AutocleaninvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.AutocleaninvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.AutocleaninvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.AutocleaninvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.AutocleaninvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.AutocleaninvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.AutocleaninvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.AutocleaninvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckMessage provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) CheckMessage(ctx context.Context, in *grpc.CheckmessageRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.CheckmessageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.CheckmessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CheckmessageRequest, ...google_golang_orggrpc.CallOption) (*grpc.CheckmessageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CheckmessageRequest, ...google_golang_orggrpc.CallOption) *grpc.CheckmessageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.CheckmessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.CheckmessageRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Close provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Close(ctx context.Context, in *grpc.CloseRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.CloseResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.CloseResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CloseRequest, ...google_golang_orggrpc.CallOption) (*grpc.CloseResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CloseRequest, ...google_golang_orggrpc.CallOption) *grpc.CloseResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.CloseResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.CloseRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConnectPeer provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ConnectPeer(ctx context.Context, in *grpc.ConnectRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ConnectResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ConnectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ConnectRequest, ...google_golang_orggrpc.CallOption) (*grpc.ConnectResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ConnectRequest, ...google_golang_orggrpc.CallOption) *grpc.ConnectResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ConnectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ConnectRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) CreateInvoice(ctx context.Context, in *grpc.CreateinvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.CreateinvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.CreateinvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CreateinvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.CreateinvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CreateinvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.CreateinvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.CreateinvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.CreateinvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateOnion provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) CreateOnion(ctx context.Context, in *grpc.CreateonionRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.CreateonionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.CreateonionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CreateonionRequest, ...google_golang_orggrpc.CallOption) (*grpc.CreateonionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.CreateonionRequest, ...google_golang_orggrpc.CallOption) *grpc.CreateonionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.CreateonionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.CreateonionRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Datastore provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Datastore(ctx context.Context, in *grpc.DatastoreRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.DatastoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.DatastoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DatastoreRequest, ...google_golang_orggrpc.CallOption) (*grpc.DatastoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DatastoreRequest, ...google_golang_orggrpc.CallOption) *grpc.DatastoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.DatastoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.DatastoreRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Decode provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Decode(ctx context.Context, in *grpc.DecodeRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.DecodeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.DecodeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DecodeRequest, ...google_golang_orggrpc.CallOption) (*grpc.DecodeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DecodeRequest, ...google_golang_orggrpc.CallOption) *grpc.DecodeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.DecodeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.DecodeRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodePay provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) DecodePay(ctx context.Context, in *grpc.DecodepayRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.DecodepayResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.DecodepayResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DecodepayRequest, ...google_golang_orggrpc.CallOption) (*grpc.DecodepayResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DecodepayRequest, ...google_golang_orggrpc.CallOption) *grpc.DecodepayResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.DecodepayResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.DecodepayRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DelDatastore provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) DelDatastore(ctx context.Context, in *grpc.DeldatastoreRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.DeldatastoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.DeldatastoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DeldatastoreRequest, ...google_golang_orggrpc.CallOption) (*grpc.DeldatastoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DeldatastoreRequest, ...google_golang_orggrpc.CallOption) *grpc.DeldatastoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.DeldatastoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.DeldatastoreRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DelExpiredInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) DelExpiredInvoice(ctx context.Context, in *grpc.DelexpiredinvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.DelexpiredinvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.DelexpiredinvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DelexpiredinvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.DelexpiredinvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DelexpiredinvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.DelexpiredinvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.DelexpiredinvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.DelexpiredinvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DelInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) DelInvoice(ctx context.Context, in *grpc.DelinvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.DelinvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.DelinvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DelinvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.DelinvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DelinvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.DelinvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.DelinvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.DelinvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Disconnect provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Disconnect(ctx context.Context, in *grpc.DisconnectRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.DisconnectResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.DisconnectResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DisconnectRequest, ...google_golang_orggrpc.CallOption) (*grpc.DisconnectResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.DisconnectRequest, ...google_golang_orggrpc.CallOption) *grpc.DisconnectResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.DisconnectResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.DisconnectRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Feerates provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Feerates(ctx context.Context, in *grpc.FeeratesRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.FeeratesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.FeeratesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.FeeratesRequest, ...google_golang_orggrpc.CallOption) (*grpc.FeeratesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.FeeratesRequest, ...google_golang_orggrpc.CallOption) *grpc.FeeratesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.FeeratesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.FeeratesRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FundChannel provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) FundChannel(ctx context.Context, in *grpc.FundchannelRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.FundchannelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.FundchannelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.FundchannelRequest, ...google_golang_orggrpc.CallOption) (*grpc.FundchannelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.FundchannelRequest, ...google_golang_orggrpc.CallOption) *grpc.FundchannelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.FundchannelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.FundchannelRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FundPsbt provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) FundPsbt(ctx context.Context, in *grpc.FundpsbtRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.FundpsbtResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.FundpsbtResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.FundpsbtRequest, ...google_golang_orggrpc.CallOption) (*grpc.FundpsbtResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.FundpsbtRequest, ...google_golang_orggrpc.CallOption) *grpc.FundpsbtResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.FundpsbtResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.FundpsbtRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRoute provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) GetRoute(ctx context.Context, in *grpc.GetrouteRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.GetrouteResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.GetrouteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.GetrouteRequest, ...google_golang_orggrpc.CallOption) (*grpc.GetrouteResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.GetrouteRequest, ...google_golang_orggrpc.CallOption) *grpc.GetrouteResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.GetrouteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.GetrouteRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Getinfo provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Getinfo(ctx context.Context, in *grpc.GetinfoRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.GetinfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.GetinfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.GetinfoRequest, ...google_golang_orggrpc.CallOption) (*grpc.GetinfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.GetinfoRequest, ...google_golang_orggrpc.CallOption) *grpc.GetinfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.GetinfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.GetinfoRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Invoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Invoice(ctx context.Context, in *grpc.InvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.InvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.InvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.InvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.InvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.InvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.InvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.InvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.InvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// KeySend provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) KeySend(ctx context.Context, in *grpc.KeysendRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.KeysendResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.KeysendResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.KeysendRequest, ...google_golang_orggrpc.CallOption) (*grpc.KeysendResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.KeysendRequest, ...google_golang_orggrpc.CallOption) *grpc.KeysendResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.KeysendResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.KeysendRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListChannels provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListChannels(ctx context.Context, in *grpc.ListchannelsRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListchannelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListchannelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListchannelsRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListchannelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListchannelsRequest, ...google_golang_orggrpc.CallOption) *grpc.ListchannelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListchannelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListchannelsRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListClosedChannels provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListClosedChannels(ctx context.Context, in *grpc.ListclosedchannelsRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListclosedchannelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListclosedchannelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListclosedchannelsRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListclosedchannelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListclosedchannelsRequest, ...google_golang_orggrpc.CallOption) *grpc.ListclosedchannelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListclosedchannelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListclosedchannelsRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListDatastore provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListDatastore(ctx context.Context, in *grpc.ListdatastoreRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListdatastoreResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListdatastoreResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListdatastoreRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListdatastoreResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListdatastoreRequest, ...google_golang_orggrpc.CallOption) *grpc.ListdatastoreResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListdatastoreResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListdatastoreRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListForwards provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListForwards(ctx context.Context, in *grpc.ListforwardsRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListforwardsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListforwardsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListforwardsRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListforwardsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListforwardsRequest, ...google_golang_orggrpc.CallOption) *grpc.ListforwardsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListforwardsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListforwardsRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListFunds provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListFunds(ctx context.Context, in *grpc.ListfundsRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListfundsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListfundsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListfundsRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListfundsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListfundsRequest, ...google_golang_orggrpc.CallOption) *grpc.ListfundsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListfundsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListfundsRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInvoices provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListInvoices(ctx context.Context, in *grpc.ListinvoicesRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListinvoicesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListinvoicesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListinvoicesRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListinvoicesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListinvoicesRequest, ...google_golang_orggrpc.CallOption) *grpc.ListinvoicesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListinvoicesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListinvoicesRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListNodes provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListNodes(ctx context.Context, in *grpc.ListnodesRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListnodesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListnodesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListnodesRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListnodesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListnodesRequest, ...google_golang_orggrpc.CallOption) *grpc.ListnodesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListnodesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListnodesRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPays provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListPays(ctx context.Context, in *grpc.ListpaysRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListpaysResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListpaysResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListpaysRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListpaysResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListpaysRequest, ...google_golang_orggrpc.CallOption) *grpc.ListpaysResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListpaysResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListpaysRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPeerChannels provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListPeerChannels(ctx context.Context, in *grpc.ListpeerchannelsRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListpeerchannelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListpeerchannelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListpeerchannelsRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListpeerchannelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListpeerchannelsRequest, ...google_golang_orggrpc.CallOption) *grpc.ListpeerchannelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListpeerchannelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListpeerchannelsRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPeers provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListPeers(ctx context.Context, in *grpc.ListpeersRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListpeersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListpeersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListpeersRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListpeersResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListpeersRequest, ...google_golang_orggrpc.CallOption) *grpc.ListpeersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListpeersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListpeersRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListSendPays provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListSendPays(ctx context.Context, in *grpc.ListsendpaysRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListsendpaysResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListsendpaysResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListsendpaysRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListsendpaysResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListsendpaysRequest, ...google_golang_orggrpc.CallOption) *grpc.ListsendpaysResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListsendpaysResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListsendpaysRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListTransactions provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) ListTransactions(ctx context.Context, in *grpc.ListtransactionsRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.ListtransactionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.ListtransactionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListtransactionsRequest, ...google_golang_orggrpc.CallOption) (*grpc.ListtransactionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.ListtransactionsRequest, ...google_golang_orggrpc.CallOption) *grpc.ListtransactionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.ListtransactionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.ListtransactionsRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewAddr provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) NewAddr(ctx context.Context, in *grpc.NewaddrRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.NewaddrResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.NewaddrResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.NewaddrRequest, ...google_golang_orggrpc.CallOption) (*grpc.NewaddrResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.NewaddrRequest, ...google_golang_orggrpc.CallOption) *grpc.NewaddrResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.NewaddrResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.NewaddrRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Pay provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Pay(ctx context.Context, in *grpc.PayRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.PayResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.PayResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PayRequest, ...google_golang_orggrpc.CallOption) (*grpc.PayResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PayRequest, ...google_golang_orggrpc.CallOption) *grpc.PayResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.PayResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.PayRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Ping provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Ping(ctx context.Context, in *grpc.PingRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.PingResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.PingResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PingRequest, ...google_golang_orggrpc.CallOption) (*grpc.PingResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PingRequest, ...google_golang_orggrpc.CallOption) *grpc.PingResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.PingResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.PingRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PreApproveInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) PreApproveInvoice(ctx context.Context, in *grpc.PreapproveinvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.PreapproveinvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.PreapproveinvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PreapproveinvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.PreapproveinvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PreapproveinvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.PreapproveinvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.PreapproveinvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.PreapproveinvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PreApproveKeysend provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) PreApproveKeysend(ctx context.Context, in *grpc.PreapprovekeysendRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.PreapprovekeysendResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.PreapprovekeysendResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PreapprovekeysendRequest, ...google_golang_orggrpc.CallOption) (*grpc.PreapprovekeysendResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.PreapprovekeysendRequest, ...google_golang_orggrpc.CallOption) *grpc.PreapprovekeysendResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.PreapprovekeysendResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.PreapprovekeysendRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendCustomMsg provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SendCustomMsg(ctx context.Context, in *grpc.SendcustommsgRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SendcustommsgResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SendcustommsgResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendcustommsgRequest, ...google_golang_orggrpc.CallOption) (*grpc.SendcustommsgResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendcustommsgRequest, ...google_golang_orggrpc.CallOption) *grpc.SendcustommsgResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SendcustommsgResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SendcustommsgRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendOnion provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SendOnion(ctx context.Context, in *grpc.SendonionRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SendonionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SendonionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendonionRequest, ...google_golang_orggrpc.CallOption) (*grpc.SendonionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendonionRequest, ...google_golang_orggrpc.CallOption) *grpc.SendonionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SendonionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SendonionRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendPay provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SendPay(ctx context.Context, in *grpc.SendpayRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SendpayResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SendpayResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendpayRequest, ...google_golang_orggrpc.CallOption) (*grpc.SendpayResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendpayRequest, ...google_golang_orggrpc.CallOption) *grpc.SendpayResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SendpayResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SendpayRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendPsbt provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SendPsbt(ctx context.Context, in *grpc.SendpsbtRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SendpsbtResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SendpsbtResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendpsbtRequest, ...google_golang_orggrpc.CallOption) (*grpc.SendpsbtResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SendpsbtRequest, ...google_golang_orggrpc.CallOption) *grpc.SendpsbtResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SendpsbtResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SendpsbtRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetChannel provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SetChannel(ctx context.Context, in *grpc.SetchannelRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SetchannelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SetchannelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SetchannelRequest, ...google_golang_orggrpc.CallOption) (*grpc.SetchannelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SetchannelRequest, ...google_golang_orggrpc.CallOption) *grpc.SetchannelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SetchannelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SetchannelRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SignInvoice(ctx context.Context, in *grpc.SigninvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SigninvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SigninvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SigninvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.SigninvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SigninvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.SigninvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SigninvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SigninvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignMessage provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SignMessage(ctx context.Context, in *grpc.SignmessageRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SignmessageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SignmessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SignmessageRequest, ...google_golang_orggrpc.CallOption) (*grpc.SignmessageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SignmessageRequest, ...google_golang_orggrpc.CallOption) *grpc.SignmessageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SignmessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SignmessageRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignPsbt provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) SignPsbt(ctx context.Context, in *grpc.SignpsbtRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.SignpsbtResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.SignpsbtResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SignpsbtRequest, ...google_golang_orggrpc.CallOption) (*grpc.SignpsbtResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.SignpsbtRequest, ...google_golang_orggrpc.CallOption) *grpc.SignpsbtResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.SignpsbtResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.SignpsbtRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Stop provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Stop(ctx context.Context, in *grpc.StopRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.StopResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.StopResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.StopRequest, ...google_golang_orggrpc.CallOption) (*grpc.StopResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.StopRequest, ...google_golang_orggrpc.CallOption) *grpc.StopResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.StopResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.StopRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TxDiscard provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) TxDiscard(ctx context.Context, in *grpc.TxdiscardRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.TxdiscardResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.TxdiscardResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.TxdiscardRequest, ...google_golang_orggrpc.CallOption) (*grpc.TxdiscardResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.TxdiscardRequest, ...google_golang_orggrpc.CallOption) *grpc.TxdiscardResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.TxdiscardResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.TxdiscardRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TxPrepare provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) TxPrepare(ctx context.Context, in *grpc.TxprepareRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.TxprepareResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.TxprepareResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.TxprepareRequest, ...google_golang_orggrpc.CallOption) (*grpc.TxprepareResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.TxprepareRequest, ...google_golang_orggrpc.CallOption) *grpc.TxprepareResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.TxprepareResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.TxprepareRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// TxSend provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) TxSend(ctx context.Context, in *grpc.TxsendRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.TxsendResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.TxsendResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.TxsendRequest, ...google_golang_orggrpc.CallOption) (*grpc.TxsendResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.TxsendRequest, ...google_golang_orggrpc.CallOption) *grpc.TxsendResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.TxsendResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.TxsendRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UtxoPsbt provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) UtxoPsbt(ctx context.Context, in *grpc.UtxopsbtRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.UtxopsbtResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.UtxopsbtResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.UtxopsbtRequest, ...google_golang_orggrpc.CallOption) (*grpc.UtxopsbtResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.UtxopsbtRequest, ...google_golang_orggrpc.CallOption) *grpc.UtxopsbtResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.UtxopsbtResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.UtxopsbtRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitAnyInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) WaitAnyInvoice(ctx context.Context, in *grpc.WaitanyinvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.WaitanyinvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.WaitanyinvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WaitanyinvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.WaitanyinvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WaitanyinvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.WaitanyinvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.WaitanyinvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.WaitanyinvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitInvoice provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) WaitInvoice(ctx context.Context, in *grpc.WaitinvoiceRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.WaitinvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.WaitinvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WaitinvoiceRequest, ...google_golang_orggrpc.CallOption) (*grpc.WaitinvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WaitinvoiceRequest, ...google_golang_orggrpc.CallOption) *grpc.WaitinvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.WaitinvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.WaitinvoiceRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WaitSendPay provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) WaitSendPay(ctx context.Context, in *grpc.WaitsendpayRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.WaitsendpayResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.WaitsendpayResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WaitsendpayRequest, ...google_golang_orggrpc.CallOption) (*grpc.WaitsendpayResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WaitsendpayRequest, ...google_golang_orggrpc.CallOption) *grpc.WaitsendpayResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.WaitsendpayResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.WaitsendpayRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Withdraw provides a mock function with given fields: ctx, in, opts
func (_m *NodeClient) Withdraw(ctx context.Context, in *grpc.WithdrawRequest, opts ...google_golang_orggrpc.CallOption) (*grpc.WithdrawResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *grpc.WithdrawResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WithdrawRequest, ...google_golang_orggrpc.CallOption) (*grpc.WithdrawResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *grpc.WithdrawRequest, ...google_golang_orggrpc.CallOption) *grpc.WithdrawResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*grpc.WithdrawResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *grpc.WithdrawRequest, ...google_golang_orggrpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewNodeClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewNodeClient creates a new instance of NodeClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewNodeClient(t mockConstructorTestingTNewNodeClient) *NodeClient {
	mock := &NodeClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
