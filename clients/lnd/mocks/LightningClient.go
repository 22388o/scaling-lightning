// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
	context "context"

	grpc "google.golang.org/grpc"

	lnrpc "github.com/lightningnetwork/lnd/lnrpc"

	mock "github.com/stretchr/testify/mock"
)

// LightningClient is an autogenerated mock type for the LightningClient type
type LightningClient struct {
	mock.Mock
}

// AbandonChannel provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) AbandonChannel(ctx context.Context, in *lnrpc.AbandonChannelRequest, opts ...grpc.CallOption) (*lnrpc.AbandonChannelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.AbandonChannelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.AbandonChannelRequest, ...grpc.CallOption) (*lnrpc.AbandonChannelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.AbandonChannelRequest, ...grpc.CallOption) *lnrpc.AbandonChannelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.AbandonChannelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.AbandonChannelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AddInvoice provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) AddInvoice(ctx context.Context, in *lnrpc.Invoice, opts ...grpc.CallOption) (*lnrpc.AddInvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.AddInvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.Invoice, ...grpc.CallOption) (*lnrpc.AddInvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.Invoice, ...grpc.CallOption) *lnrpc.AddInvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.AddInvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.Invoice, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BakeMacaroon provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) BakeMacaroon(ctx context.Context, in *lnrpc.BakeMacaroonRequest, opts ...grpc.CallOption) (*lnrpc.BakeMacaroonResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.BakeMacaroonResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.BakeMacaroonRequest, ...grpc.CallOption) (*lnrpc.BakeMacaroonResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.BakeMacaroonRequest, ...grpc.CallOption) *lnrpc.BakeMacaroonResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.BakeMacaroonResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.BakeMacaroonRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BatchOpenChannel provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) BatchOpenChannel(ctx context.Context, in *lnrpc.BatchOpenChannelRequest, opts ...grpc.CallOption) (*lnrpc.BatchOpenChannelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.BatchOpenChannelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.BatchOpenChannelRequest, ...grpc.CallOption) (*lnrpc.BatchOpenChannelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.BatchOpenChannelRequest, ...grpc.CallOption) *lnrpc.BatchOpenChannelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.BatchOpenChannelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.BatchOpenChannelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelAcceptor provides a mock function with given fields: ctx, opts
func (_m *LightningClient) ChannelAcceptor(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_ChannelAcceptorClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_ChannelAcceptorClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) (lnrpc.Lightning_ChannelAcceptorClient, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) lnrpc.Lightning_ChannelAcceptorClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_ChannelAcceptorClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ChannelBalance provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ChannelBalance(ctx context.Context, in *lnrpc.ChannelBalanceRequest, opts ...grpc.CallOption) (*lnrpc.ChannelBalanceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ChannelBalanceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelBalanceRequest, ...grpc.CallOption) (*lnrpc.ChannelBalanceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelBalanceRequest, ...grpc.CallOption) *lnrpc.ChannelBalanceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ChannelBalanceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ChannelBalanceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckMacaroonPermissions provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) CheckMacaroonPermissions(ctx context.Context, in *lnrpc.CheckMacPermRequest, opts ...grpc.CallOption) (*lnrpc.CheckMacPermResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.CheckMacPermResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.CheckMacPermRequest, ...grpc.CallOption) (*lnrpc.CheckMacPermResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.CheckMacPermRequest, ...grpc.CallOption) *lnrpc.CheckMacPermResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.CheckMacPermResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.CheckMacPermRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CloseChannel provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) CloseChannel(ctx context.Context, in *lnrpc.CloseChannelRequest, opts ...grpc.CallOption) (lnrpc.Lightning_CloseChannelClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_CloseChannelClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.CloseChannelRequest, ...grpc.CallOption) (lnrpc.Lightning_CloseChannelClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.CloseChannelRequest, ...grpc.CallOption) lnrpc.Lightning_CloseChannelClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_CloseChannelClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.CloseChannelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ClosedChannels provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ClosedChannels(ctx context.Context, in *lnrpc.ClosedChannelsRequest, opts ...grpc.CallOption) (*lnrpc.ClosedChannelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ClosedChannelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ClosedChannelsRequest, ...grpc.CallOption) (*lnrpc.ClosedChannelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ClosedChannelsRequest, ...grpc.CallOption) *lnrpc.ClosedChannelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ClosedChannelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ClosedChannelsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConnectPeer provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ConnectPeer(ctx context.Context, in *lnrpc.ConnectPeerRequest, opts ...grpc.CallOption) (*lnrpc.ConnectPeerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ConnectPeerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ConnectPeerRequest, ...grpc.CallOption) (*lnrpc.ConnectPeerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ConnectPeerRequest, ...grpc.CallOption) *lnrpc.ConnectPeerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ConnectPeerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ConnectPeerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DebugLevel provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) DebugLevel(ctx context.Context, in *lnrpc.DebugLevelRequest, opts ...grpc.CallOption) (*lnrpc.DebugLevelResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.DebugLevelResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DebugLevelRequest, ...grpc.CallOption) (*lnrpc.DebugLevelResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DebugLevelRequest, ...grpc.CallOption) *lnrpc.DebugLevelResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.DebugLevelResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.DebugLevelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DecodePayReq provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) DecodePayReq(ctx context.Context, in *lnrpc.PayReqString, opts ...grpc.CallOption) (*lnrpc.PayReq, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.PayReq
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PayReqString, ...grpc.CallOption) (*lnrpc.PayReq, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PayReqString, ...grpc.CallOption) *lnrpc.PayReq); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.PayReq)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.PayReqString, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteAllPayments provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) DeleteAllPayments(ctx context.Context, in *lnrpc.DeleteAllPaymentsRequest, opts ...grpc.CallOption) (*lnrpc.DeleteAllPaymentsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.DeleteAllPaymentsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DeleteAllPaymentsRequest, ...grpc.CallOption) (*lnrpc.DeleteAllPaymentsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DeleteAllPaymentsRequest, ...grpc.CallOption) *lnrpc.DeleteAllPaymentsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.DeleteAllPaymentsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.DeleteAllPaymentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteMacaroonID provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) DeleteMacaroonID(ctx context.Context, in *lnrpc.DeleteMacaroonIDRequest, opts ...grpc.CallOption) (*lnrpc.DeleteMacaroonIDResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.DeleteMacaroonIDResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DeleteMacaroonIDRequest, ...grpc.CallOption) (*lnrpc.DeleteMacaroonIDResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DeleteMacaroonIDRequest, ...grpc.CallOption) *lnrpc.DeleteMacaroonIDResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.DeleteMacaroonIDResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.DeleteMacaroonIDRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeletePayment provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) DeletePayment(ctx context.Context, in *lnrpc.DeletePaymentRequest, opts ...grpc.CallOption) (*lnrpc.DeletePaymentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.DeletePaymentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DeletePaymentRequest, ...grpc.CallOption) (*lnrpc.DeletePaymentResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DeletePaymentRequest, ...grpc.CallOption) *lnrpc.DeletePaymentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.DeletePaymentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.DeletePaymentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DescribeGraph provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) DescribeGraph(ctx context.Context, in *lnrpc.ChannelGraphRequest, opts ...grpc.CallOption) (*lnrpc.ChannelGraph, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ChannelGraph
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelGraphRequest, ...grpc.CallOption) (*lnrpc.ChannelGraph, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelGraphRequest, ...grpc.CallOption) *lnrpc.ChannelGraph); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ChannelGraph)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ChannelGraphRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DisconnectPeer provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) DisconnectPeer(ctx context.Context, in *lnrpc.DisconnectPeerRequest, opts ...grpc.CallOption) (*lnrpc.DisconnectPeerResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.DisconnectPeerResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DisconnectPeerRequest, ...grpc.CallOption) (*lnrpc.DisconnectPeerResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.DisconnectPeerRequest, ...grpc.CallOption) *lnrpc.DisconnectPeerResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.DisconnectPeerResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.DisconnectPeerRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// EstimateFee provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) EstimateFee(ctx context.Context, in *lnrpc.EstimateFeeRequest, opts ...grpc.CallOption) (*lnrpc.EstimateFeeResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.EstimateFeeResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.EstimateFeeRequest, ...grpc.CallOption) (*lnrpc.EstimateFeeResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.EstimateFeeRequest, ...grpc.CallOption) *lnrpc.EstimateFeeResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.EstimateFeeResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.EstimateFeeRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportAllChannelBackups provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ExportAllChannelBackups(ctx context.Context, in *lnrpc.ChanBackupExportRequest, opts ...grpc.CallOption) (*lnrpc.ChanBackupSnapshot, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ChanBackupSnapshot
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChanBackupExportRequest, ...grpc.CallOption) (*lnrpc.ChanBackupSnapshot, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChanBackupExportRequest, ...grpc.CallOption) *lnrpc.ChanBackupSnapshot); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ChanBackupSnapshot)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ChanBackupExportRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ExportChannelBackup provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ExportChannelBackup(ctx context.Context, in *lnrpc.ExportChannelBackupRequest, opts ...grpc.CallOption) (*lnrpc.ChannelBackup, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ChannelBackup
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ExportChannelBackupRequest, ...grpc.CallOption) (*lnrpc.ChannelBackup, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ExportChannelBackupRequest, ...grpc.CallOption) *lnrpc.ChannelBackup); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ChannelBackup)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ExportChannelBackupRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FeeReport provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) FeeReport(ctx context.Context, in *lnrpc.FeeReportRequest, opts ...grpc.CallOption) (*lnrpc.FeeReportResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.FeeReportResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.FeeReportRequest, ...grpc.CallOption) (*lnrpc.FeeReportResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.FeeReportRequest, ...grpc.CallOption) *lnrpc.FeeReportResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.FeeReportResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.FeeReportRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ForwardingHistory provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ForwardingHistory(ctx context.Context, in *lnrpc.ForwardingHistoryRequest, opts ...grpc.CallOption) (*lnrpc.ForwardingHistoryResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ForwardingHistoryResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ForwardingHistoryRequest, ...grpc.CallOption) (*lnrpc.ForwardingHistoryResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ForwardingHistoryRequest, ...grpc.CallOption) *lnrpc.ForwardingHistoryResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ForwardingHistoryResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ForwardingHistoryRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FundingStateStep provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) FundingStateStep(ctx context.Context, in *lnrpc.FundingTransitionMsg, opts ...grpc.CallOption) (*lnrpc.FundingStateStepResp, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.FundingStateStepResp
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.FundingTransitionMsg, ...grpc.CallOption) (*lnrpc.FundingStateStepResp, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.FundingTransitionMsg, ...grpc.CallOption) *lnrpc.FundingStateStepResp); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.FundingStateStepResp)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.FundingTransitionMsg, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetChanInfo provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) GetChanInfo(ctx context.Context, in *lnrpc.ChanInfoRequest, opts ...grpc.CallOption) (*lnrpc.ChannelEdge, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ChannelEdge
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChanInfoRequest, ...grpc.CallOption) (*lnrpc.ChannelEdge, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChanInfoRequest, ...grpc.CallOption) *lnrpc.ChannelEdge); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ChannelEdge)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ChanInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetInfo provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) GetInfo(ctx context.Context, in *lnrpc.GetInfoRequest, opts ...grpc.CallOption) (*lnrpc.GetInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.GetInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetInfoRequest, ...grpc.CallOption) (*lnrpc.GetInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetInfoRequest, ...grpc.CallOption) *lnrpc.GetInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.GetInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.GetInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNetworkInfo provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) GetNetworkInfo(ctx context.Context, in *lnrpc.NetworkInfoRequest, opts ...grpc.CallOption) (*lnrpc.NetworkInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.NetworkInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NetworkInfoRequest, ...grpc.CallOption) (*lnrpc.NetworkInfo, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NetworkInfoRequest, ...grpc.CallOption) *lnrpc.NetworkInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.NetworkInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.NetworkInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeInfo provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) GetNodeInfo(ctx context.Context, in *lnrpc.NodeInfoRequest, opts ...grpc.CallOption) (*lnrpc.NodeInfo, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.NodeInfo
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NodeInfoRequest, ...grpc.CallOption) (*lnrpc.NodeInfo, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NodeInfoRequest, ...grpc.CallOption) *lnrpc.NodeInfo); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.NodeInfo)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.NodeInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetNodeMetrics provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) GetNodeMetrics(ctx context.Context, in *lnrpc.NodeMetricsRequest, opts ...grpc.CallOption) (*lnrpc.NodeMetricsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.NodeMetricsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NodeMetricsRequest, ...grpc.CallOption) (*lnrpc.NodeMetricsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NodeMetricsRequest, ...grpc.CallOption) *lnrpc.NodeMetricsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.NodeMetricsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.NodeMetricsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetRecoveryInfo provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) GetRecoveryInfo(ctx context.Context, in *lnrpc.GetRecoveryInfoRequest, opts ...grpc.CallOption) (*lnrpc.GetRecoveryInfoResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.GetRecoveryInfoResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetRecoveryInfoRequest, ...grpc.CallOption) (*lnrpc.GetRecoveryInfoResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetRecoveryInfoRequest, ...grpc.CallOption) *lnrpc.GetRecoveryInfoResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.GetRecoveryInfoResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.GetRecoveryInfoRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetTransactions provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) GetTransactions(ctx context.Context, in *lnrpc.GetTransactionsRequest, opts ...grpc.CallOption) (*lnrpc.TransactionDetails, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.TransactionDetails
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetTransactionsRequest, ...grpc.CallOption) (*lnrpc.TransactionDetails, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetTransactionsRequest, ...grpc.CallOption) *lnrpc.TransactionDetails); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.TransactionDetails)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.GetTransactionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListAliases provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListAliases(ctx context.Context, in *lnrpc.ListAliasesRequest, opts ...grpc.CallOption) (*lnrpc.ListAliasesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListAliasesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListAliasesRequest, ...grpc.CallOption) (*lnrpc.ListAliasesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListAliasesRequest, ...grpc.CallOption) *lnrpc.ListAliasesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListAliasesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListAliasesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListChannels provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListChannels(ctx context.Context, in *lnrpc.ListChannelsRequest, opts ...grpc.CallOption) (*lnrpc.ListChannelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListChannelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListChannelsRequest, ...grpc.CallOption) (*lnrpc.ListChannelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListChannelsRequest, ...grpc.CallOption) *lnrpc.ListChannelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListChannelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListChannelsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListInvoices provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListInvoices(ctx context.Context, in *lnrpc.ListInvoiceRequest, opts ...grpc.CallOption) (*lnrpc.ListInvoiceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListInvoiceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListInvoiceRequest, ...grpc.CallOption) (*lnrpc.ListInvoiceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListInvoiceRequest, ...grpc.CallOption) *lnrpc.ListInvoiceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListInvoiceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListInvoiceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListMacaroonIDs provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListMacaroonIDs(ctx context.Context, in *lnrpc.ListMacaroonIDsRequest, opts ...grpc.CallOption) (*lnrpc.ListMacaroonIDsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListMacaroonIDsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListMacaroonIDsRequest, ...grpc.CallOption) (*lnrpc.ListMacaroonIDsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListMacaroonIDsRequest, ...grpc.CallOption) *lnrpc.ListMacaroonIDsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListMacaroonIDsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListMacaroonIDsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPayments provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListPayments(ctx context.Context, in *lnrpc.ListPaymentsRequest, opts ...grpc.CallOption) (*lnrpc.ListPaymentsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListPaymentsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListPaymentsRequest, ...grpc.CallOption) (*lnrpc.ListPaymentsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListPaymentsRequest, ...grpc.CallOption) *lnrpc.ListPaymentsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListPaymentsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListPaymentsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPeers provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListPeers(ctx context.Context, in *lnrpc.ListPeersRequest, opts ...grpc.CallOption) (*lnrpc.ListPeersResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListPeersResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListPeersRequest, ...grpc.CallOption) (*lnrpc.ListPeersResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListPeersRequest, ...grpc.CallOption) *lnrpc.ListPeersResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListPeersResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListPeersRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListPermissions provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListPermissions(ctx context.Context, in *lnrpc.ListPermissionsRequest, opts ...grpc.CallOption) (*lnrpc.ListPermissionsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListPermissionsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListPermissionsRequest, ...grpc.CallOption) (*lnrpc.ListPermissionsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListPermissionsRequest, ...grpc.CallOption) *lnrpc.ListPermissionsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListPermissionsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListPermissionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListUnspent provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) ListUnspent(ctx context.Context, in *lnrpc.ListUnspentRequest, opts ...grpc.CallOption) (*lnrpc.ListUnspentResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ListUnspentResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListUnspentRequest, ...grpc.CallOption) (*lnrpc.ListUnspentResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ListUnspentRequest, ...grpc.CallOption) *lnrpc.ListUnspentResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ListUnspentResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ListUnspentRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LookupHtlcResolution provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) LookupHtlcResolution(ctx context.Context, in *lnrpc.LookupHtlcResolutionRequest, opts ...grpc.CallOption) (*lnrpc.LookupHtlcResolutionResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.LookupHtlcResolutionResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.LookupHtlcResolutionRequest, ...grpc.CallOption) (*lnrpc.LookupHtlcResolutionResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.LookupHtlcResolutionRequest, ...grpc.CallOption) *lnrpc.LookupHtlcResolutionResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.LookupHtlcResolutionResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.LookupHtlcResolutionRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// LookupInvoice provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) LookupInvoice(ctx context.Context, in *lnrpc.PaymentHash, opts ...grpc.CallOption) (*lnrpc.Invoice, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.Invoice
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PaymentHash, ...grpc.CallOption) (*lnrpc.Invoice, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PaymentHash, ...grpc.CallOption) *lnrpc.Invoice); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.Invoice)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.PaymentHash, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewAddress provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) NewAddress(ctx context.Context, in *lnrpc.NewAddressRequest, opts ...grpc.CallOption) (*lnrpc.NewAddressResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.NewAddressResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NewAddressRequest, ...grpc.CallOption) (*lnrpc.NewAddressResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.NewAddressRequest, ...grpc.CallOption) *lnrpc.NewAddressResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.NewAddressResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.NewAddressRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenChannel provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) OpenChannel(ctx context.Context, in *lnrpc.OpenChannelRequest, opts ...grpc.CallOption) (lnrpc.Lightning_OpenChannelClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_OpenChannelClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.OpenChannelRequest, ...grpc.CallOption) (lnrpc.Lightning_OpenChannelClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.OpenChannelRequest, ...grpc.CallOption) lnrpc.Lightning_OpenChannelClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_OpenChannelClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.OpenChannelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenChannelSync provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) OpenChannelSync(ctx context.Context, in *lnrpc.OpenChannelRequest, opts ...grpc.CallOption) (*lnrpc.ChannelPoint, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.ChannelPoint
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.OpenChannelRequest, ...grpc.CallOption) (*lnrpc.ChannelPoint, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.OpenChannelRequest, ...grpc.CallOption) *lnrpc.ChannelPoint); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.ChannelPoint)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.OpenChannelRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PendingChannels provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) PendingChannels(ctx context.Context, in *lnrpc.PendingChannelsRequest, opts ...grpc.CallOption) (*lnrpc.PendingChannelsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.PendingChannelsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PendingChannelsRequest, ...grpc.CallOption) (*lnrpc.PendingChannelsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PendingChannelsRequest, ...grpc.CallOption) *lnrpc.PendingChannelsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.PendingChannelsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.PendingChannelsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// QueryRoutes provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) QueryRoutes(ctx context.Context, in *lnrpc.QueryRoutesRequest, opts ...grpc.CallOption) (*lnrpc.QueryRoutesResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.QueryRoutesResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.QueryRoutesRequest, ...grpc.CallOption) (*lnrpc.QueryRoutesResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.QueryRoutesRequest, ...grpc.CallOption) *lnrpc.QueryRoutesResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.QueryRoutesResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.QueryRoutesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RegisterRPCMiddleware provides a mock function with given fields: ctx, opts
func (_m *LightningClient) RegisterRPCMiddleware(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_RegisterRPCMiddlewareClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_RegisterRPCMiddlewareClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) (lnrpc.Lightning_RegisterRPCMiddlewareClient, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) lnrpc.Lightning_RegisterRPCMiddlewareClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_RegisterRPCMiddlewareClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// RestoreChannelBackups provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) RestoreChannelBackups(ctx context.Context, in *lnrpc.RestoreChanBackupRequest, opts ...grpc.CallOption) (*lnrpc.RestoreBackupResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.RestoreBackupResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.RestoreChanBackupRequest, ...grpc.CallOption) (*lnrpc.RestoreBackupResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.RestoreChanBackupRequest, ...grpc.CallOption) *lnrpc.RestoreBackupResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.RestoreBackupResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.RestoreChanBackupRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendCoins provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SendCoins(ctx context.Context, in *lnrpc.SendCoinsRequest, opts ...grpc.CallOption) (*lnrpc.SendCoinsResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.SendCoinsResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendCoinsRequest, ...grpc.CallOption) (*lnrpc.SendCoinsResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendCoinsRequest, ...grpc.CallOption) *lnrpc.SendCoinsResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.SendCoinsResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.SendCoinsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendCustomMessage provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SendCustomMessage(ctx context.Context, in *lnrpc.SendCustomMessageRequest, opts ...grpc.CallOption) (*lnrpc.SendCustomMessageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.SendCustomMessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendCustomMessageRequest, ...grpc.CallOption) (*lnrpc.SendCustomMessageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendCustomMessageRequest, ...grpc.CallOption) *lnrpc.SendCustomMessageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.SendCustomMessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.SendCustomMessageRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendMany provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SendMany(ctx context.Context, in *lnrpc.SendManyRequest, opts ...grpc.CallOption) (*lnrpc.SendManyResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.SendManyResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendManyRequest, ...grpc.CallOption) (*lnrpc.SendManyResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendManyRequest, ...grpc.CallOption) *lnrpc.SendManyResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.SendManyResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.SendManyRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendPayment provides a mock function with given fields: ctx, opts
func (_m *LightningClient) SendPayment(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_SendPaymentClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SendPaymentClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) (lnrpc.Lightning_SendPaymentClient, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) lnrpc.Lightning_SendPaymentClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SendPaymentClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendPaymentSync provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SendPaymentSync(ctx context.Context, in *lnrpc.SendRequest, opts ...grpc.CallOption) (*lnrpc.SendResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.SendResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendRequest, ...grpc.CallOption) (*lnrpc.SendResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendRequest, ...grpc.CallOption) *lnrpc.SendResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.SendResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.SendRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendToRoute provides a mock function with given fields: ctx, opts
func (_m *LightningClient) SendToRoute(ctx context.Context, opts ...grpc.CallOption) (lnrpc.Lightning_SendToRouteClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SendToRouteClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) (lnrpc.Lightning_SendToRouteClient, error)); ok {
		return rf(ctx, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, ...grpc.CallOption) lnrpc.Lightning_SendToRouteClient); ok {
		r0 = rf(ctx, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SendToRouteClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendToRouteSync provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SendToRouteSync(ctx context.Context, in *lnrpc.SendToRouteRequest, opts ...grpc.CallOption) (*lnrpc.SendResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.SendResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendToRouteRequest, ...grpc.CallOption) (*lnrpc.SendResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SendToRouteRequest, ...grpc.CallOption) *lnrpc.SendResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.SendResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.SendToRouteRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignMessage provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SignMessage(ctx context.Context, in *lnrpc.SignMessageRequest, opts ...grpc.CallOption) (*lnrpc.SignMessageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.SignMessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SignMessageRequest, ...grpc.CallOption) (*lnrpc.SignMessageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SignMessageRequest, ...grpc.CallOption) *lnrpc.SignMessageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.SignMessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.SignMessageRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// StopDaemon provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) StopDaemon(ctx context.Context, in *lnrpc.StopRequest, opts ...grpc.CallOption) (*lnrpc.StopResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.StopResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.StopRequest, ...grpc.CallOption) (*lnrpc.StopResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.StopRequest, ...grpc.CallOption) *lnrpc.StopResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.StopResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.StopRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeChannelBackups provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SubscribeChannelBackups(ctx context.Context, in *lnrpc.ChannelBackupSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelBackupsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SubscribeChannelBackupsClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelBackupSubscription, ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelBackupsClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelBackupSubscription, ...grpc.CallOption) lnrpc.Lightning_SubscribeChannelBackupsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SubscribeChannelBackupsClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ChannelBackupSubscription, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeChannelEvents provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SubscribeChannelEvents(ctx context.Context, in *lnrpc.ChannelEventSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelEventsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SubscribeChannelEventsClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelEventSubscription, ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelEventsClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChannelEventSubscription, ...grpc.CallOption) lnrpc.Lightning_SubscribeChannelEventsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SubscribeChannelEventsClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ChannelEventSubscription, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeChannelGraph provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SubscribeChannelGraph(ctx context.Context, in *lnrpc.GraphTopologySubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelGraphClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SubscribeChannelGraphClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GraphTopologySubscription, ...grpc.CallOption) (lnrpc.Lightning_SubscribeChannelGraphClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GraphTopologySubscription, ...grpc.CallOption) lnrpc.Lightning_SubscribeChannelGraphClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SubscribeChannelGraphClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.GraphTopologySubscription, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeCustomMessages provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SubscribeCustomMessages(ctx context.Context, in *lnrpc.SubscribeCustomMessagesRequest, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeCustomMessagesClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SubscribeCustomMessagesClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SubscribeCustomMessagesRequest, ...grpc.CallOption) (lnrpc.Lightning_SubscribeCustomMessagesClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.SubscribeCustomMessagesRequest, ...grpc.CallOption) lnrpc.Lightning_SubscribeCustomMessagesClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SubscribeCustomMessagesClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.SubscribeCustomMessagesRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeInvoices provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SubscribeInvoices(ctx context.Context, in *lnrpc.InvoiceSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeInvoicesClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SubscribeInvoicesClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.InvoiceSubscription, ...grpc.CallOption) (lnrpc.Lightning_SubscribeInvoicesClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.InvoiceSubscription, ...grpc.CallOption) lnrpc.Lightning_SubscribeInvoicesClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SubscribeInvoicesClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.InvoiceSubscription, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribePeerEvents provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SubscribePeerEvents(ctx context.Context, in *lnrpc.PeerEventSubscription, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribePeerEventsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SubscribePeerEventsClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PeerEventSubscription, ...grpc.CallOption) (lnrpc.Lightning_SubscribePeerEventsClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PeerEventSubscription, ...grpc.CallOption) lnrpc.Lightning_SubscribePeerEventsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SubscribePeerEventsClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.PeerEventSubscription, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubscribeTransactions provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) SubscribeTransactions(ctx context.Context, in *lnrpc.GetTransactionsRequest, opts ...grpc.CallOption) (lnrpc.Lightning_SubscribeTransactionsClient, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 lnrpc.Lightning_SubscribeTransactionsClient
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetTransactionsRequest, ...grpc.CallOption) (lnrpc.Lightning_SubscribeTransactionsClient, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.GetTransactionsRequest, ...grpc.CallOption) lnrpc.Lightning_SubscribeTransactionsClient); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(lnrpc.Lightning_SubscribeTransactionsClient)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.GetTransactionsRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateChannelPolicy provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) UpdateChannelPolicy(ctx context.Context, in *lnrpc.PolicyUpdateRequest, opts ...grpc.CallOption) (*lnrpc.PolicyUpdateResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.PolicyUpdateResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PolicyUpdateRequest, ...grpc.CallOption) (*lnrpc.PolicyUpdateResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.PolicyUpdateRequest, ...grpc.CallOption) *lnrpc.PolicyUpdateResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.PolicyUpdateResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.PolicyUpdateRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyChanBackup provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) VerifyChanBackup(ctx context.Context, in *lnrpc.ChanBackupSnapshot, opts ...grpc.CallOption) (*lnrpc.VerifyChanBackupResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.VerifyChanBackupResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChanBackupSnapshot, ...grpc.CallOption) (*lnrpc.VerifyChanBackupResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.ChanBackupSnapshot, ...grpc.CallOption) *lnrpc.VerifyChanBackupResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.VerifyChanBackupResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.ChanBackupSnapshot, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// VerifyMessage provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) VerifyMessage(ctx context.Context, in *lnrpc.VerifyMessageRequest, opts ...grpc.CallOption) (*lnrpc.VerifyMessageResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.VerifyMessageResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.VerifyMessageRequest, ...grpc.CallOption) (*lnrpc.VerifyMessageResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.VerifyMessageRequest, ...grpc.CallOption) *lnrpc.VerifyMessageResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.VerifyMessageResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.VerifyMessageRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WalletBalance provides a mock function with given fields: ctx, in, opts
func (_m *LightningClient) WalletBalance(ctx context.Context, in *lnrpc.WalletBalanceRequest, opts ...grpc.CallOption) (*lnrpc.WalletBalanceResponse, error) {
	_va := make([]interface{}, len(opts))
	for _i := range opts {
		_va[_i] = opts[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, ctx, in)
	_ca = append(_ca, _va...)
	ret := _m.Called(_ca...)

	var r0 *lnrpc.WalletBalanceResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.WalletBalanceRequest, ...grpc.CallOption) (*lnrpc.WalletBalanceResponse, error)); ok {
		return rf(ctx, in, opts...)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *lnrpc.WalletBalanceRequest, ...grpc.CallOption) *lnrpc.WalletBalanceResponse); ok {
		r0 = rf(ctx, in, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*lnrpc.WalletBalanceResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *lnrpc.WalletBalanceRequest, ...grpc.CallOption) error); ok {
		r1 = rf(ctx, in, opts...)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewLightningClient creates a new instance of LightningClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLightningClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *LightningClient {
	mock := &LightningClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
