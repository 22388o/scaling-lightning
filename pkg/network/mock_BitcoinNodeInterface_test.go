// Code generated by mockery v2.34.2. DO NOT EDIT.

package network

import (
	bitcoinnode "github.com/scaling-lightning/scaling-lightning/pkg/bitcoinnode"
	bitcoin "github.com/scaling-lightning/scaling-lightning/pkg/standardclient/bitcoin"

	common "github.com/scaling-lightning/scaling-lightning/pkg/standardclient/common"

	mock "github.com/stretchr/testify/mock"

	types "github.com/scaling-lightning/scaling-lightning/pkg/types"
)

// MockBitcoinNodeInterface is an autogenerated mock type for the BitcoinNodeInterface type
type MockBitcoinNodeInterface struct {
	mock.Mock
}

type MockBitcoinNodeInterface_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBitcoinNodeInterface) EXPECT() *MockBitcoinNodeInterface_Expecter {
	return &MockBitcoinNodeInterface_Expecter{mock: &_m.Mock}
}

// Generate provides a mock function with given fields: client, commonClient, numBlocks
func (_m *MockBitcoinNodeInterface) Generate(client bitcoin.BitcoinClient, commonClient common.CommonClient, numBlocks uint32) ([]string, error) {
	ret := _m.Called(client, commonClient, numBlocks)

	var r0 []string
	var r1 error
	if rf, ok := ret.Get(0).(func(bitcoin.BitcoinClient, common.CommonClient, uint32) ([]string, error)); ok {
		return rf(client, commonClient, numBlocks)
	}
	if rf, ok := ret.Get(0).(func(bitcoin.BitcoinClient, common.CommonClient, uint32) []string); ok {
		r0 = rf(client, commonClient, numBlocks)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	if rf, ok := ret.Get(1).(func(bitcoin.BitcoinClient, common.CommonClient, uint32) error); ok {
		r1 = rf(client, commonClient, numBlocks)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBitcoinNodeInterface_Generate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Generate'
type MockBitcoinNodeInterface_Generate_Call struct {
	*mock.Call
}

// Generate is a helper method to define mock.On call
//   - client bitcoin.BitcoinClient
//   - commonClient common.CommonClient
//   - numBlocks uint32
func (_e *MockBitcoinNodeInterface_Expecter) Generate(client interface{}, commonClient interface{}, numBlocks interface{}) *MockBitcoinNodeInterface_Generate_Call {
	return &MockBitcoinNodeInterface_Generate_Call{Call: _e.mock.On("Generate", client, commonClient, numBlocks)}
}

func (_c *MockBitcoinNodeInterface_Generate_Call) Run(run func(client bitcoin.BitcoinClient, commonClient common.CommonClient, numBlocks uint32)) *MockBitcoinNodeInterface_Generate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(bitcoin.BitcoinClient), args[1].(common.CommonClient), args[2].(uint32))
	})
	return _c
}

func (_c *MockBitcoinNodeInterface_Generate_Call) Return(hashes []string, err error) *MockBitcoinNodeInterface_Generate_Call {
	_c.Call.Return(hashes, err)
	return _c
}

func (_c *MockBitcoinNodeInterface_Generate_Call) RunAndReturn(run func(bitcoin.BitcoinClient, common.CommonClient, uint32) ([]string, error)) *MockBitcoinNodeInterface_Generate_Call {
	_c.Call.Return(run)
	return _c
}

// GetConnectionPorts provides a mock function with given fields: kubeConfig
func (_m *MockBitcoinNodeInterface) GetConnectionPorts(kubeConfig string) ([]bitcoinnode.ConnectionPorts, error) {
	ret := _m.Called(kubeConfig)

	var r0 []bitcoinnode.ConnectionPorts
	var r1 error
	if rf, ok := ret.Get(0).(func(string) ([]bitcoinnode.ConnectionPorts, error)); ok {
		return rf(kubeConfig)
	}
	if rf, ok := ret.Get(0).(func(string) []bitcoinnode.ConnectionPorts); ok {
		r0 = rf(kubeConfig)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]bitcoinnode.ConnectionPorts)
		}
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(kubeConfig)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBitcoinNodeInterface_GetConnectionPorts_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConnectionPorts'
type MockBitcoinNodeInterface_GetConnectionPorts_Call struct {
	*mock.Call
}

// GetConnectionPorts is a helper method to define mock.On call
//   - kubeConfig string
func (_e *MockBitcoinNodeInterface_Expecter) GetConnectionPorts(kubeConfig interface{}) *MockBitcoinNodeInterface_GetConnectionPorts_Call {
	return &MockBitcoinNodeInterface_GetConnectionPorts_Call{Call: _e.mock.On("GetConnectionPorts", kubeConfig)}
}

func (_c *MockBitcoinNodeInterface_GetConnectionPorts_Call) Run(run func(kubeConfig string)) *MockBitcoinNodeInterface_GetConnectionPorts_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string))
	})
	return _c
}

func (_c *MockBitcoinNodeInterface_GetConnectionPorts_Call) Return(_a0 []bitcoinnode.ConnectionPorts, _a1 error) *MockBitcoinNodeInterface_GetConnectionPorts_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBitcoinNodeInterface_GetConnectionPorts_Call) RunAndReturn(run func(string) ([]bitcoinnode.ConnectionPorts, error)) *MockBitcoinNodeInterface_GetConnectionPorts_Call {
	_c.Call.Return(run)
	return _c
}

// GetName provides a mock function with given fields:
func (_m *MockBitcoinNodeInterface) GetName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// MockBitcoinNodeInterface_GetName_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetName'
type MockBitcoinNodeInterface_GetName_Call struct {
	*mock.Call
}

// GetName is a helper method to define mock.On call
func (_e *MockBitcoinNodeInterface_Expecter) GetName() *MockBitcoinNodeInterface_GetName_Call {
	return &MockBitcoinNodeInterface_GetName_Call{Call: _e.mock.On("GetName")}
}

func (_c *MockBitcoinNodeInterface_GetName_Call) Run(run func()) *MockBitcoinNodeInterface_GetName_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockBitcoinNodeInterface_GetName_Call) Return(_a0 string) *MockBitcoinNodeInterface_GetName_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockBitcoinNodeInterface_GetName_Call) RunAndReturn(run func() string) *MockBitcoinNodeInterface_GetName_Call {
	_c.Call.Return(run)
	return _c
}

// GetNewAddress provides a mock function with given fields: client
func (_m *MockBitcoinNodeInterface) GetNewAddress(client common.CommonClient) (string, error) {
	ret := _m.Called(client)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(common.CommonClient) (string, error)); ok {
		return rf(client)
	}
	if rf, ok := ret.Get(0).(func(common.CommonClient) string); ok {
		r0 = rf(client)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(common.CommonClient) error); ok {
		r1 = rf(client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBitcoinNodeInterface_GetNewAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetNewAddress'
type MockBitcoinNodeInterface_GetNewAddress_Call struct {
	*mock.Call
}

// GetNewAddress is a helper method to define mock.On call
//   - client common.CommonClient
func (_e *MockBitcoinNodeInterface_Expecter) GetNewAddress(client interface{}) *MockBitcoinNodeInterface_GetNewAddress_Call {
	return &MockBitcoinNodeInterface_GetNewAddress_Call{Call: _e.mock.On("GetNewAddress", client)}
}

func (_c *MockBitcoinNodeInterface_GetNewAddress_Call) Run(run func(client common.CommonClient)) *MockBitcoinNodeInterface_GetNewAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.CommonClient))
	})
	return _c
}

func (_c *MockBitcoinNodeInterface_GetNewAddress_Call) Return(_a0 string, _a1 error) *MockBitcoinNodeInterface_GetNewAddress_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBitcoinNodeInterface_GetNewAddress_Call) RunAndReturn(run func(common.CommonClient) (string, error)) *MockBitcoinNodeInterface_GetNewAddress_Call {
	_c.Call.Return(run)
	return _c
}

// GetWalletBalance provides a mock function with given fields: client
func (_m *MockBitcoinNodeInterface) GetWalletBalance(client common.CommonClient) (types.Amount, error) {
	ret := _m.Called(client)

	var r0 types.Amount
	var r1 error
	if rf, ok := ret.Get(0).(func(common.CommonClient) (types.Amount, error)); ok {
		return rf(client)
	}
	if rf, ok := ret.Get(0).(func(common.CommonClient) types.Amount); ok {
		r0 = rf(client)
	} else {
		r0 = ret.Get(0).(types.Amount)
	}

	if rf, ok := ret.Get(1).(func(common.CommonClient) error); ok {
		r1 = rf(client)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBitcoinNodeInterface_GetWalletBalance_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetWalletBalance'
type MockBitcoinNodeInterface_GetWalletBalance_Call struct {
	*mock.Call
}

// GetWalletBalance is a helper method to define mock.On call
//   - client common.CommonClient
func (_e *MockBitcoinNodeInterface_Expecter) GetWalletBalance(client interface{}) *MockBitcoinNodeInterface_GetWalletBalance_Call {
	return &MockBitcoinNodeInterface_GetWalletBalance_Call{Call: _e.mock.On("GetWalletBalance", client)}
}

func (_c *MockBitcoinNodeInterface_GetWalletBalance_Call) Run(run func(client common.CommonClient)) *MockBitcoinNodeInterface_GetWalletBalance_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.CommonClient))
	})
	return _c
}

func (_c *MockBitcoinNodeInterface_GetWalletBalance_Call) Return(_a0 types.Amount, _a1 error) *MockBitcoinNodeInterface_GetWalletBalance_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockBitcoinNodeInterface_GetWalletBalance_Call) RunAndReturn(run func(common.CommonClient) (types.Amount, error)) *MockBitcoinNodeInterface_GetWalletBalance_Call {
	_c.Call.Return(run)
	return _c
}

// SendToAddress provides a mock function with given fields: client, address, amount
func (_m *MockBitcoinNodeInterface) SendToAddress(client common.CommonClient, address string, amount types.Amount) (string, error) {
	ret := _m.Called(client, address, amount)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(common.CommonClient, string, types.Amount) (string, error)); ok {
		return rf(client, address, amount)
	}
	if rf, ok := ret.Get(0).(func(common.CommonClient, string, types.Amount) string); ok {
		r0 = rf(client, address, amount)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(common.CommonClient, string, types.Amount) error); ok {
		r1 = rf(client, address, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockBitcoinNodeInterface_SendToAddress_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'SendToAddress'
type MockBitcoinNodeInterface_SendToAddress_Call struct {
	*mock.Call
}

// SendToAddress is a helper method to define mock.On call
//   - client common.CommonClient
//   - address string
//   - amount types.Amount
func (_e *MockBitcoinNodeInterface_Expecter) SendToAddress(client interface{}, address interface{}, amount interface{}) *MockBitcoinNodeInterface_SendToAddress_Call {
	return &MockBitcoinNodeInterface_SendToAddress_Call{Call: _e.mock.On("SendToAddress", client, address, amount)}
}

func (_c *MockBitcoinNodeInterface_SendToAddress_Call) Run(run func(client common.CommonClient, address string, amount types.Amount)) *MockBitcoinNodeInterface_SendToAddress_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(common.CommonClient), args[1].(string), args[2].(types.Amount))
	})
	return _c
}

func (_c *MockBitcoinNodeInterface_SendToAddress_Call) Return(TxId string, err error) *MockBitcoinNodeInterface_SendToAddress_Call {
	_c.Call.Return(TxId, err)
	return _c
}

func (_c *MockBitcoinNodeInterface_SendToAddress_Call) RunAndReturn(run func(common.CommonClient, string, types.Amount) (string, error)) *MockBitcoinNodeInterface_SendToAddress_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBitcoinNodeInterface creates a new instance of MockBitcoinNodeInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBitcoinNodeInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBitcoinNodeInterface {
	mock := &MockBitcoinNodeInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
