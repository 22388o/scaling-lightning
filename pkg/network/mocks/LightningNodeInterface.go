// Code generated by mockery v2.32.4. DO NOT EDIT.

package mocks

import (
	network "github.com/scaling-lightning/scaling-lightning/pkg/network"
	types "github.com/scaling-lightning/scaling-lightning/pkg/types"
	mock "github.com/stretchr/testify/mock"
)

// LightningNodeInterface is an autogenerated mock type for the LightningNodeInterface type
type LightningNodeInterface struct {
	mock.Mock
}

// ChannelBalance provides a mock function with given fields:
func (_m *LightningNodeInterface) ChannelBalance() (types.Amount, error) {
	ret := _m.Called()

	var r0 types.Amount
	var r1 error
	if rf, ok := ret.Get(0).(func() (types.Amount, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() types.Amount); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(types.Amount)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConnectPeer provides a mock function with given fields: to
func (_m *LightningNodeInterface) ConnectPeer(to network.Node) error {
	ret := _m.Called(to)

	var r0 error
	if rf, ok := ret.Get(0).(func(network.Node) error); ok {
		r0 = rf(to)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateInvoice provides a mock function with given fields: amountSats
func (_m *LightningNodeInterface) CreateInvoice(amountSats uint64) (string, error) {
	ret := _m.Called(amountSats)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(uint64) (string, error)); ok {
		return rf(amountSats)
	}
	if rf, ok := ret.Get(0).(func(uint64) string); ok {
		r0 = rf(amountSats)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(uint64) error); ok {
		r1 = rf(amountSats)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConnectionDetails provides a mock function with given fields:
func (_m *LightningNodeInterface) GetConnectionDetails() (network.ConnectionDetails, error) {
	ret := _m.Called()

	var r0 network.ConnectionDetails
	var r1 error
	if rf, ok := ret.Get(0).(func() (network.ConnectionDetails, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() network.ConnectionDetails); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(network.ConnectionDetails)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetConnectionFiles provides a mock function with given fields:
func (_m *LightningNodeInterface) GetConnectionFiles() (*network.ConnectionFiles, error) {
	ret := _m.Called()

	var r0 *network.ConnectionFiles
	var r1 error
	if rf, ok := ret.Get(0).(func() (*network.ConnectionFiles, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() *network.ConnectionFiles); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*network.ConnectionFiles)
		}
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetName provides a mock function with given fields:
func (_m *LightningNodeInterface) GetName() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// GetNewAddress provides a mock function with given fields:
func (_m *LightningNodeInterface) GetNewAddress() (string, error) {
	ret := _m.Called()

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func() (string, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetPubKey provides a mock function with given fields:
func (_m *LightningNodeInterface) GetPubKey() (types.PubKey, error) {
	ret := _m.Called()

	var r0 types.PubKey
	var r1 error
	if rf, ok := ret.Get(0).(func() (types.PubKey, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() types.PubKey); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(types.PubKey)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetWalletBalance provides a mock function with given fields:
func (_m *LightningNodeInterface) GetWalletBalance() (types.Amount, error) {
	ret := _m.Called()

	var r0 types.Amount
	var r1 error
	if rf, ok := ret.Get(0).(func() (types.Amount, error)); ok {
		return rf()
	}
	if rf, ok := ret.Get(0).(func() types.Amount); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(types.Amount)
	}

	if rf, ok := ret.Get(1).(func() error); ok {
		r1 = rf()
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// OpenChannel provides a mock function with given fields: to, localAmt
func (_m *LightningNodeInterface) OpenChannel(to *network.LightningNode, localAmt types.Amount) (types.ChannelPoint, error) {
	ret := _m.Called(to, localAmt)

	var r0 types.ChannelPoint
	var r1 error
	if rf, ok := ret.Get(0).(func(*network.LightningNode, types.Amount) (types.ChannelPoint, error)); ok {
		return rf(to, localAmt)
	}
	if rf, ok := ret.Get(0).(func(*network.LightningNode, types.Amount) types.ChannelPoint); ok {
		r0 = rf(to, localAmt)
	} else {
		r0 = ret.Get(0).(types.ChannelPoint)
	}

	if rf, ok := ret.Get(1).(func(*network.LightningNode, types.Amount) error); ok {
		r1 = rf(to, localAmt)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PayInvoice provides a mock function with given fields: invoice
func (_m *LightningNodeInterface) PayInvoice(invoice string) (string, error) {
	ret := _m.Called(invoice)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (string, error)); ok {
		return rf(invoice)
	}
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(invoice)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(invoice)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Send provides a mock function with given fields: to, amount
func (_m *LightningNodeInterface) Send(to network.Node, amount types.Amount) (string, error) {
	ret := _m.Called(to, amount)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(network.Node, types.Amount) (string, error)); ok {
		return rf(to, amount)
	}
	if rf, ok := ret.Get(0).(func(network.Node, types.Amount) string); ok {
		r0 = rf(to, amount)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(network.Node, types.Amount) error); ok {
		r1 = rf(to, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SendToAddress provides a mock function with given fields: address, amount
func (_m *LightningNodeInterface) SendToAddress(address string, amount types.Amount) (string, error) {
	ret := _m.Called(address, amount)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(string, types.Amount) (string, error)); ok {
		return rf(address, amount)
	}
	if rf, ok := ret.Get(0).(func(string, types.Amount) string); ok {
		r0 = rf(address, amount)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(string, types.Amount) error); ok {
		r1 = rf(address, amount)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// WriteAuthFilesToDirectory provides a mock function with given fields: dir
func (_m *LightningNodeInterface) WriteAuthFilesToDirectory(dir string) error {
	ret := _m.Called(dir)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(dir)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewLightningNodeInterface creates a new instance of LightningNodeInterface. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewLightningNodeInterface(t interface {
	mock.TestingT
	Cleanup(func())
}) *LightningNodeInterface {
	mock := &LightningNodeInterface{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
